# -*- coding: utf-8 -*-
# SubeSat 6U: bus realista, paneles solares definidos y escudo térmico coherente
# Autor: Víctor & Copilot
# Workbench: Part

import FreeCAD as App
import FreeCADGui as Gui
import Part
import math

DOC_NAME = "SubeSat_6U_Coherent"

def ensure_document(name):
    doc = App.ActiveDocument
    if doc is None or doc.Name != name:
        try:
            doc = App.newDocument(name)
        except Exception:
            doc = App.ActiveDocument
    return doc

# Helpers geométricos
def box(x, y, z): return Part.makeBox(x, y, z)
def cyl(r, h): return Part.makeCylinder(r, h)
def cone(r1, r2, h): return Part.makeCone(r1, r2, h)

def safe_fillet(shape, r):
    if r <= 0: return shape
    try: return shape.makeFillet(r, shape.Edges)
    except Exception: return shape

def safe_chamfer(shape, r):
    if r <= 0: return shape
    try: return shape.makeChamfer(r, shape.Edges)
    except Exception: return shape

class P:
    # Escala 6U (aproximación: ANCHO x LARGO x ALTO)
    sx = 100.0   # ancho (X)
    sy = 226.0   # largo (Y) ~ 2U en Y
    sz = 340.0   # alto (Z) ~ 3U apilados (para lectura 6U en volumen)
    wall = 3.2   # espesor de pared
    edge_chamfer = 1.2
    edge_fillet  = 0.8

    # Rails tipo P-POD (lectura mecánica)
    add_rails = True
    rail_size = 5.0
    rail_offset = 2.0

    # Escudo térmico (TPS) frontal coherente
    add_tps = True
    tps_diameter   = 190.0     # mayor que la sección del bus
    tps_thickness  = 6.0       # disco sandwich
    tps_cone_height= 16.0      # nariz cónica
    tps_tilt_deg   = 5.0       # ligera inclinación
    tps_rib_count  = 10        # nervaduras radiales
    tps_rib_th     = 3.0
    tps_rim_th     = 3.0       # anillo de borde (protector)

    # Sunshade (baffles tras el TPS)
    add_sunshade = True
    shade_ring_count = 3
    shade_ring_th = 2.0
    shade_gap = 10.0

    # Paneles solares definidos
    add_solar = True
    solar_w = 120.0
    solar_h = 160.0
    solar_th = 2.2
    solar_angle_deg = 25.0
    hinge_th = 4.0
    cell_cols = 8
    cell_rows = 10
    add_filter_layer = True
    add_back_ribs = True
    engrave_depth = 0.6   # usado en modo lite

    # Whipple selectivo (placas sencillas laterales para look técnico)
    add_whipple = True
    whipple_outer_th = 1.6
    whipple_faces = ["+X"]

    # Radiador inferior simplificado
    add_radiator = True
    rad_plate_th = 3.0
    rad_louvre_count = 6
    rad_louvre_th = 2.0
    rad_louvre_gap = 7.0

    # Performance y acabado
    preview = False          # True: ligero, False: full detalle paneles
    small_fillet  = 0.5
    small_chamfer = 0.5

# --- BUS 6U con cavidad y rails ---
def make_bus_6u(p: P):
    shell = box(p.sx, p.sy, p.sz)
    inner = box(p.sx - 2*p.wall, p.sy - 2*p.wall, p.sz - 2*p.wall)
    inner.translate(App.Vector(p.wall, p.wall, p.wall))
    bus = shell.cut(inner)

    if p.add_rails:
        rail = box(p.rail_size, p.rail_size, p.sz)
        positions = [
            App.Vector(p.rail_offset, p.rail_offset, 0),
            App.Vector(p.sx - p.rail_offset - p.rail_size, p.rail_offset, 0),
            App.Vector(p.rail_offset, p.sy - p.rail_offset - p.rail_size, 0),
            App.Vector(p.sx - p.rail_offset - p.rail_size, p.sy - p.rail_offset - p.rail_size, 0),
        ]
        rails = []
        for pos in positions:
            r = rail.copy(); r.translate(pos); rails.append(r)
        for r in rails: bus = bus.fuse(r)

    bus = safe_chamfer(bus, p.edge_chamfer)
    bus = safe_fillet(bus, p.edge_fillet)
    return bus

# --- TPS coherente: disco + nariz + rim + ribs ---
def make_tps(p: P):
    R = p.tps_diameter/2.0
    disk = cyl(R, p.tps_thickness)
    disk.translate(App.Vector(p.sx/2 - R, p.sy/2 - R, p.sz))  # en top (+Z)

    nose = cone(R, R*0.6, p.tps_cone_height)
    nose.translate(App.Vector(p.sx/2, p.sy/2, p.sz + p.tps_thickness))

    rim = cyl(R, p.tps_rim_th)
    rim.translate(App.Vector(p.sx/2 - R, p.sy/2 - R, p.sz - p.tps_rim_th))

    ribs = []
    for i in range(p.tps_rib_count):
        ang = 360.0*i/p.tps_rib_count
        rib = box(p.tps_rib_th, R*1.85, p.tps_thickness*0.7)
        rib.translate(App.Vector(p.sx/2 - p.tps_rib_th/2, p.sy/2 - R*0.925, p.sz))
        rib = rib.rotate(App.Vector(p.sx/2, p.sy/2, p.sz), App.Vector(0,0,1), ang)
        ribs.append(rib)

    tps = disk.fuse(nose).fuse(rim)
    for r in ribs: tps = tps.fuse(r)
    if abs(p.tps_tilt_deg) > 1e-6:
        tps = tps.rotate(App.Vector(p.sx/2, p.sy/2, p.sz), App.Vector(1,0,0), p.tps_tilt_deg)
    return safe_fillet(tps, p.small_fillet)

# --- Sunshade: anillos concéntricos tras el TPS ---
def make_sunshade(p: P):
    solids = []
    R = p.tps_diameter/2.0 - 8.0
    for i in range(p.shade_ring_count):
        ringR = R - i*p.shade_gap
        if ringR <= 12: break
        ring = cyl(ringR, p.shade_ring_th)
        ring.translate(App.Vector(p.sx/2 - ringR, p.sy/2 - ringR, p.sz - (i+1)*p.shade_ring_th - 4))
        solids.append(safe_fillet(ring, 0.3))
    return solids

# --- Panel solar FULL: celdas, filtro y ribs traseros (pieza única) ---
def make_detailed_panel_full(p: P, w, h, t, cols, rows, add_filter=True, add_ribs=True):
    frame = box(w, h, t)
    frame = safe_fillet(frame, 0.4)
    cell_w = w / cols
    cell_h = h / rows

    # Construimos celdas por filas, fusionando por bloques para reducir booleanas
    panel = frame
    for j in range(rows):
        row_solid = None
        for i in range(cols):
            cw = cell_w * 0.9
            ch = cell_h * 0.9
            cell = box(cw, ch, t*0.5)
            cell.translate(App.Vector(i*cell_w + (cell_w-cw)/2,
                                      j*cell_h + (cell_h-ch)/2,
                                      t))
            row_solid = cell if row_solid is None else row_solid.fuse(cell)
        panel = panel.fuse(row_solid)

    if add_filter:
        filter_layer = box(w, h, t*0.2)
        filter_layer.translate(App.Vector(0,0,t*1.5))
        panel = panel.fuse(filter_layer)

    if add_ribs:
        pitch = 10.0
        count = max(1, int(w / pitch))
        ribs = None
        for i in range(count):
            rib = box(1.2, h, t*0.6)
            rib.translate(App.Vector(i*pitch, 0, -t*0.6))
            ribs = rib if ribs is None else ribs.fuse(rib)
        panel = panel.fuse(ribs)

    return safe_chamfer(panel, 0.3)

# --- Panel solar LITE: retícula grabada por corte (rápido) ---
def make_detailed_panel_lite(p: P, w, h, t, cols, rows, depth):
    panel = box(w, h, t)
    # Cortes de retícula: canales superficiales
    cell_w = w / cols
    cell_h = h / rows
    grooves = None
    for i in range(1, cols):
        g = box(0.8, h, depth)
        g.translate(App.Vector(i*cell_w - 0.4, 0, t - depth))
        grooves = g if grooves is None else grooves.fuse(g)
    for j in range(1, rows):
        g = box(w, 0.8, depth)
        g.translate(App.Vector(0, j*cell_h - 0.4, t - depth))
        grooves = grooves.fuse(g)
    panel = panel.cut(grooves)
    return safe_chamfer(panel, 0.3)

# --- Arrays solares con bisagra y ángulo de seguimiento ---
def make_solar_arrays(p: P):
    panels = []
    for side in ['+Y', '-Y']:
        if p.preview:
            panel = make_detailed_panel_lite(p, p.solar_w, p.solar_h, p.solar_th, p.cell_cols, p.cell_rows, p.engrave_depth)
        else:
            panel = make_detailed_panel_full(p, p.solar_w, p.solar_h, p.solar_th, p.cell_cols, p.cell_rows, p.add_filter_layer, p.add_back_ribs)
        hinge = box(p.hinge_th, p.solar_w, p.solar_th)
        # Posicionamiento y rotación (gimbal en eje X)
        if side == '+Y':
            base = App.Vector(p.sx/2 - p.solar_w/2, p.sy + p.solar_th, p.sz/2 - p.solar_h/2)
            panel.translate(base)
            hinge.translate(App.Vector(p.sx/2 - p.solar_w/2 - p.hinge_th, p.sy, p.sz/2 - p.solar_h/2))
            axis_pt = App.Vector(p.sx/2, p.sy, p.sz/2)
            panel = panel.rotate(axis_pt, App.Vector(1,0,0), p.solar_angle_deg)
        else:
            base = App.Vector(p.sx/2 - p.solar_w/2, -p.solar_th - p.hinge_th, p.sz/2 - p.solar_h/2)
            panel.translate(base)
            hinge.translate(App.Vector(p.sx/2 - p.solar_w/2 - p.hinge_th, -p.hinge_th, p.sz/2 - p.solar_h/2))
            axis_pt = App.Vector(p.sx/2, 0, p.sz/2)
            panel = panel.rotate(axis_pt, App.Vector(1,0,0), -p.solar_angle_deg)
        panels.append(hinge.fuse(panel))
    return panels

# --- Radiador inferior con lamas simplificadas ---
def make_radiator(p: P):
    solids = []
    plate = box(p.sx - 2*p.wall, p.sy - 2*p.wall, p.rad_plate_th)
    plate.translate(App.Vector(p.wall, p.wall, -p.rad_plate_th))
    solids.append(plate)

    pitch = p.rad_louvre_th + p.rad_louvre_gap
    count = min(p.rad_louvre_count, int((p.sx - 2*p.wall)/pitch))
    lamas = None
    for i in range(count):
        lx = p.wall + i*pitch
        louvre = box(p.rad_louvre_th, p.sy - 2*p.wall, p.rad_plate_th*0.7)
        louvre.translate(App.Vector(lx, p.wall, -p.rad_plate_th*0.7))
        lamas = louvre if lamas is None else lamas.fuse(louvre)
    if lamas: solids.append(lamas)
    return solids

# --- Whipple simple en caras seleccionadas ---
def make_whipple(p: P):
    solids = []
    for face in p.whipple_faces:
        if face == "+X":
            plate = box(p.whipple_outer_th, p.sy, p.sz)
            plate.translate(App.Vector(p.sx + 0.6, 0, 0))
            solids.append(plate)
        elif face == "+Y":
            plate = box(p.sx, p.whipple_outer_th, p.sz)
            plate.translate(App.Vector(0, p.sy + 0.6, 0))
            solids.append(plate)
    return solids

# --- Construcción principal ---
def build_subesat(p: P):
    doc = ensure_document(DOC_NAME)
    # Recomputation diferido para velocidad
    try: doc.SuppressRecompute = True
    except Exception: pass

    fusion = make_bus_6u(p)

    if p.add_tps:
        fusion = fusion.fuse(make_tps(p))
    if p.add_sunshade:
        for s in make_sunshade(p):
            fusion = fusion.fuse(s)

    if p.add_solar:
        for s in make_solar_arrays(p):
            fusion = fusion.fuse(s)

    if p.add_radiator:
        for s in make_radiator(p):
            fusion = fusion.fuse(s)

    if p.add_whipple:
        for s in make_whipple(p):
            fusion = fusion.fuse(s)

    try: fusion = fusion.removeSplitter()
    except Exception: pass

    obj = doc.addObject("Part::Feature", "SubeSat_6U")
    obj.Shape = fusion
    # Recentrar
    bbox = obj.Shape.BoundBox
    obj.Placement.Base = App.Vector(-bbox.XMin - bbox.XLength/2,
                                    -bbox.YMin - bbox.YLength/2,
                                    -bbox.ZMin - bbox.ZLength/2)
    try: doc.SuppressRecompute = False
    except Exception: pass
    Gui.ActiveDocument.ActiveView.viewAxonometric()
    Gui.SendMsgToActiveView("ViewFit")
    doc.recompute()
    return obj

# Preset rápido
if __name__ == "__main__":
    sat = build_subesat(P)
