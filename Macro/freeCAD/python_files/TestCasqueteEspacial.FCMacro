# -*- coding: utf-8 -*-
# Macro FreeCAD: Sonda espacial paramétrica con bus hexagonal, payload, propulsor iónico,
# escudo térmico tipo casquete, ménsulas, materiales y colores.
#
# Autor: Copilot para Víctor (Madrid)
# FreeCAD 0.20+ (probado con 0.21). No requiere Workbenches externos.
#
# Uso:
# 1) Archivo > Macros > Crear > Pegar este código > Guardar > Ejecutar.
# 2) Ajusta parámetros en la hoja "Params" y vuelve a ejecutar (F5) para actualizar.
#
# Notas:
# - El script reconstruye todo a partir de la hoja de parámetros.
# - Se añaden propiedades de material (densidad, E, k, cp) como mapa en cada pieza.
# - Ejes: Z vertical, origen en el centro del bus.

import FreeCAD as App
import Part

try:
    import FreeCADGui as Gui
    GUI_AVAILABLE = True
except Exception:
    GUI_AVAILABLE = False

DOC_NAME = "Sonda_Parametrica"

# ------------ Utilidades de unidades y lectura de celdas ------------------

def q(sheet, alias):
    """Devuelve una Quantity a partir del alias en Spreadsheet."""
    return App.Units.parseQuantity(sheet.get(alias))

def q_m(sheet, alias):
    """Devuelve valor en metros (float) a partir de una celda con unidades."""
    return q(sheet, alias).Value  # SI -> metros si la unidad es mm, etc.

def clamp(v, vmin, vmax):
    return max(vmin, min(vmax, v))

def ensure_doc(name):
    doc = App.getDocument(name) if name in App.listDocuments() else App.newDocument(name)
    # Limpieza suave: elimina todo menos la hoja Params si existe
    for obj in list(doc.Objects):
        if obj.TypeId != 'Spreadsheet::Sheet' or obj.Name != 'Params':
            try:
                doc.removeObject(obj.Name)
            except Exception:
                pass
    return doc

# --------------- Creación/actualización de hoja de parámetros --------------

def ensure_params_sheet(doc):
    sheet = doc.getObject('Params')
    if not sheet:
        sheet = doc.addObject('Spreadsheet::Sheet', 'Params')

    def safe_get(cell):
        try:
            return sheet.get(cell)
        except Exception:
            return None

    def find_row_by_alias(alias):
        for r in range(1, 2000):
            pos = f'B{r}'
            try:
                if sheet.getAlias(pos) == alias:
                    return r
            except Exception:
                pass
        return None

    def first_free_row():
        r = 1
        while r < 2000:
            a = safe_get(f'A{r}')
            b = safe_get(f'B{r}')
            if (a is None or a == '') and (b is None or b == ''):
                return r
            r += 1
        return r

    def put(alias, value_with_unit, label=None):
        # Actualiza si existe el alias; si no, añade al final
        r = find_row_by_alias(alias)
        if r is None:
            r = first_free_row()
        if label is not None:
            try:
                sheet.set(f'A{r}', label)
            except Exception:
                pass
        sheet.set(f'B{r}', str(value_with_unit))
        try:
            sheet.setAlias(f'B{r}', alias)
        except Exception:
            # Si el alias ya existe en otra celda, lo reasignamos limpiando el antiguo
            old = find_row_by_alias(alias)
            if old is not None and old != r:
                try:
                    sheet.setAlias(f'B{old}', '')
                except Exception:
                    pass
            try:
                sheet.setAlias(f'B{r}', alias)
            except Exception:
                pass

    # Dimensiones del bus
    put('bus_R', '450 mm', 'Radio externo del bus (hexágono circunscrito)')
    put('bus_H', '900 mm', 'Altura del bus')
    put('bus_t', '12 mm', 'Espesor de pared del bus')

    # Payload
    put('payload_size', '320 mm', 'Tamaño cúbico del payload')
    put('payload_z', '0 mm', 'Posición Z del centro del payload')

    # Propulsor iónico
    put('thr_R', '110 mm', 'Radio cuerpo del propulsor')
    put('thr_L', '280 mm', 'Longitud cuerpo del propulsor')
    put('thr_nozzle_L', '140 mm', 'Longitud tobera')
    put('thr_nozzle_R', '30 mm', 'Radio salida tobera')
    put('thr_offset', '40 mm', 'Separación entre bus y propulsor')

    # Escudo térmico (casquete)
    put('shield_R', '520 mm', 'Radio de la esfera del escudo')
    put('shield_h', '120 mm', 'Altura del casquete')
    put('shield_t', '4 mm', 'Espesor del escudo')

    # Ménsulas de unión
    put('brk_count', '6', 'Número de ménsulas radiales')
    put('brk_w', '18 mm', 'Ancho de ménsula')
    put('brk_h', '24 mm', 'Alto de ménsula')
    put('brk_margin', '6 mm', 'Holgura a payload y pared')

    # Márgenes globales
    put('clearance', '6 mm', 'Holgura general')
    put('min_wall', '2.5 mm', 'Espesor mínimo seguro')

    # Materiales (densidad kg/m^3, E Pa, k W/mK, cp J/kgK)
    put('mat_bus_density', '2700 kg/m^3', 'Bus Al 6061-T6 densidad')
    put('mat_bus_E', '69 GPa', 'Bus módulo elástico')
    put('mat_bus_k', '167 W/mK', 'Bus conductividad')
    put('mat_bus_cp', '875 J/kg/K', 'Bus calor específico')

    put('mat_payload_density', '1600 kg/m^3', 'Payload CFRP densidad')
    put('mat_payload_E', '70 GPa', 'Payload módulo equivalente')
    put('mat_payload_k', '5 W/mK', 'Payload conductividad')
    put('mat_payload_cp', '800 J/kg/K', 'Payload calor específico')

    put('mat_thr_density', '8200 kg/m^3', 'Thruster Inconel densidad')
    put('mat_thr_E', '205 GPa', 'Thruster módulo elástico')
    put('mat_thr_k', '11 W/mK', 'Thruster conductividad')
    put('mat_thr_cp', '450 J/kg/K', 'Thruster calor específico')

    put('mat_shield_density', '1800 kg/m^3', 'Escudo ablativo densidad')
    put('mat_shield_E', '10 GPa', 'Escudo módulo elástico')
    put('mat_shield_k', '0.3 W/mK', 'Escudo conductividad')
    put('mat_shield_cp', '1200 J/kg/K', 'Escudo calor específico')

    return sheet

# --------------- Geometría base: prismas, casquetes, etc. ------------------

def make_hex_face(R):
    """Crea una cara hexagonal regular de radio circunscrito R (m) centrada en (0,0,0)."""
    import math
    pts = []
    for i in range(6):
        ang = math.radians(60 * i + 30)  # orientado con una cara “arriba”
        pts.append(App.Vector(R * math.cos(ang), R * math.sin(ang), 0))
    pts.append(pts[0])
    wire = Part.makePolygon(pts)
    face = Part.Face(wire)
    return face

def make_hollow_hex_prism(Ro, t, H):
    """Prisma hexagonal hueco: radio externo Ro, espesor t, altura H."""
    Ri = clamp(Ro - t, 1e-6, Ro * 0.95)
    outer = make_hex_face(Ro).extrude(App.Vector(0, 0, H))
    inner = make_hex_face(Ri).extrude(App.Vector(0, 0, H))
    return outer.cut(inner), Ri

def make_box(size, center=True):
    """Cubo size x size x size; si center=True, centrado en (0,0,0)."""
    s = size
    if center:
        return Part.makeBox(s, s, s, App.Vector(-s / 2.0, -s / 2.0, -s / 2.0))
    else:
        return Part.makeBox(s, s, s)

def make_cylinder(R, L, axis=App.Vector(0, 0, 1), base=App.Vector(0, 0, 0)):
    c = Part.makeCylinder(R, L, base, axis)
    return c

def make_cone(R1, R2, L, axis=App.Vector(0, 0, 1), base=App.Vector(0, 0, 0)):
    c = Part.makeCone(R1, R2, L, base, axis)
    return c

def make_spherical_cap_shell(R, h, t, z_plane):
    """
    Crea un casquete esférico hueco:
    - R: radio de esfera
    - h: altura del casquete
    - t: espesor (R_inner = R - t)
    - z_plane: plano de corte Z = z_plane, se conserva la parte superior (z >= z_plane)
    El centro de la esfera se coloca en zc = z_plane + (R - h) para que la base del casquete coincida con z_plane.
    """
    R_inner = clamp(R - t, 1e-6, R * 0.999)
    zc = z_plane + (R - h)
    center = App.Vector(0, 0, zc)
    outer = Part.makeSphere(R, center)
    inner = Part.makeSphere(R_inner, center)
    shell = outer.cut(inner)
    # Caja superior para recortar casquete
    box = Part.makeBox(4 * R, 4 * R, 4 * R, App.Vector(-2 * R, -2 * R, z_plane))
    cap = shell.common(box)
    return cap

# ------------------------ Asignación de materiales -------------------------

def set_material(obj, density, E, k, cp, name):
    if not hasattr(obj, 'Material'):
        try:
            obj.addProperty('App::PropertyMap', 'Material', 'Material', 'Material properties')
        except Exception:
            pass
    mat = {
        'Name': name,
        'Density': f'{density} kg/m^3',
        'YoungModulus': f'{E} Pa',
        'ThermalConductivity': f'{k} W/m/K',
        'SpecificHeat': f'{cp} J/kg/K',
    }
    try:
        obj.Material = mat
    except Exception:
        pass

def set_color(obj, rgb, trans=0.0):
    if GUI_AVAILABLE:
        try:
            obj.ViewObject.ShapeColor = tuple(float(c) for c in rgb)
            obj.ViewObject.Transparency = int(trans * 100)
        except Exception:
            pass

# ----------------------------- Construcción --------------------------------

def build_probe(doc, sheet):
    # Lee parámetros (en metros y valores escalares)
    bus_R = q_m(sheet, 'bus_R')
    bus_H = q_m(sheet, 'bus_H')
    bus_t = max(q_m(sheet, 'bus_t'), q_m(sheet, 'min_wall'))

    payload_size = q_m(sheet, 'payload_size')
    payload_z = q_m(sheet, 'payload_z')

    thr_R = q_m(sheet, 'thr_R')
    thr_L = q_m(sheet, 'thr_L')
    thr_noz_L = q_m(sheet, 'thr_nozzle_L')
    thr_noz_R = q_m(sheet, 'thr_nozzle_R')
    thr_offset = q_m(sheet, 'thr_offset')

    shield_R = q_m(sheet, 'shield_R')
    shield_h = q_m(sheet, 'shield_h')
    shield_t = max(q_m(sheet, 'shield_t'), q_m(sheet, 'min_wall'))

    # N ménsulas como entero robusto
    try:
        brk_n = int(float(sheet.get('brk_count')))
    except Exception:
        brk_n = 6
    brk_n = max(3, brk_n)

    brk_w = q_m(sheet, 'brk_w')
    brk_h = q_m(sheet, 'brk_h')
    brk_margin = q_m(sheet, 'brk_margin')

    clearance = q_m(sheet, 'clearance')

    # Geometría del bus y radio interno
    bus, bus_Ri = make_hollow_hex_prism(bus_R, bus_t, bus_H)

    # Ajustes y restricciones
    import math
    r_in = bus_Ri * math.cos(math.radians(30.0))  # radio del círculo inscrito
    payload_size_hard = r_in * math.sqrt(2) - 2 * clearance
    if payload_size > payload_size_hard:
        payload_size = max(0.05, payload_size_hard)

    if abs(payload_z) + (payload_size / 2.0) > (bus_H / 2.0 - clearance):
        payload_z = 0.0

    # ------------- Contenedor principal -------------
    part = doc.addObject('App::Part', 'Sonda')
    part.Label = 'Sonda espacial paramétrica'

    # ------------- Bus hexagonal -------------
    bus_solid = doc.addObject('Part::Feature', 'Bus')
    bus_solid.Shape = bus
    bus_solid.Placement.Base = App.Vector(0, 0, -bus_H / 2.0)
    part.addObject(bus_solid)

    # ------------- Payload cúbico -------------
    payload_shape = make_box(payload_size, center=True)
    payload_obj = doc.addObject('Part::Feature', 'Payload')
    payload_obj.Shape = payload_shape
    payload_obj.Placement.Base = App.Vector(0, 0, payload_z)
    part.addObject(payload_obj)

    # ------------- Ménsulas radiales -------------
    brk_objs = []
    half = payload_size / 2.0
    L_radial = max(0.0, r_in - half - brk_margin)
    if L_radial > (brk_w * 0.5):
        for i in range(brk_n):
            ang = 2.0 * math.pi * i / brk_n
            beam = Part.makeBox(L_radial, brk_w, brk_h)
            px = half * math.cos(ang)
            py = half * math.sin(ang)
            z0 = payload_z - brk_h / 2.0
            beam.translate(App.Vector(px, py, z0))
            beam = beam.rotate(App.Vector(px, py, z0), App.Vector(0, 0, 1), math.degrees(ang))
            brk_obj = doc.addObject('Part::Feature', f'Mensula_{i+1:02d}')
            brk_obj.Shape = beam
            part.addObject(brk_obj)
            brk_objs.append(brk_obj)

    # ------------- Propulsor iónico -------------
    thr_z0 = -bus_H / 2.0 - thr_offset - thr_L  # base inferior del cilindro
    thr_body = make_cylinder(thr_R, thr_L, base=App.Vector(0, 0, thr_z0))
    thr_noz_z0 = thr_z0 - thr_noz_L
    thr_nozzle = make_cone(thr_R, thr_noz_R, thr_noz_L, base=App.Vector(0, 0, thr_noz_z0))
    thr_shape = thr_body.fuse(thr_nozzle)
    thr_obj = doc.addObject('Part::Feature', 'Thruster')
    thr_obj.Shape = thr_shape
    part.addObject(thr_obj)

    # ------------- Escudo térmico tipo casquete -------------
    z_plane = +bus_H / 2.0  # plano superior del bus
    shield = make_spherical_cap_shell(shield_R, shield_h, shield_t, z_plane)
    shield_obj = doc.addObject('Part::Feature', 'EscudoTermico')
    shield_obj.Shape = shield
    part.addObject(shield_obj)

    # ------------- Recortes de seguridad -------------
    try:
        payload_cut_zone = make_hex_face(r_in - clearance).extrude(App.Vector(0, 0, bus_H))
        payload_cut_zone.translate(App.Vector(0, 0, -bus_H / 2.0))
        safe_payload = payload_obj.Shape.common(payload_cut_zone)
        payload_obj.Shape = safe_payload
    except Exception:
        pass

    # ------------- Materiales y colores -------------
    set_material(
        bus_solid,
        density=App.Units.parseQuantity(sheet.get('mat_bus_density')).Value,
        E=App.Units.parseQuantity(sheet.get('mat_bus_E')).Value,
        k=App.Units.parseQuantity(sheet.get('mat_bus_k')).Value,
        cp=App.Units.parseQuantity(sheet.get('mat_bus_cp')).Value,
        name='Al6061-T6'
    )
    set_color(bus_solid, (0.75, 0.78, 0.82), trans=0.0)

    set_material(
        payload_obj,
        density=App.Units.parseQuantity(sheet.get('mat_payload_density')).Value,
        E=App.Units.parseQuantity(sheet.get('mat_payload_E')).Value,
        k=App.Units.parseQuantity(sheet.get('mat_payload_k')).Value,
        cp=App.Units.parseQuantity(sheet.get('mat_payload_cp')).Value,
        name='CFRP'
    )
    set_color(payload_obj, (0.10, 0.10, 0.12), trans=0.2)

    for bo in brk_objs:
        set_material(
            bo,
            density=App.Units.parseQuantity(sheet.get('mat_bus_density')).Value,
            E=App.Units.parseQuantity(sheet.get('mat_bus_E')).Value,
            k=App.Units.parseQuantity(sheet.get('mat_bus_k')).Value,
            cp=App.Units.parseQuantity(sheet.get('mat_bus_cp')).Value,
            name='Al6061-T6'
        )
        set_color(bo, (0.70, 0.73, 0.78), trans=0.0)

    set_material(
        thr_obj,
        density=App.Units.parseQuantity(sheet.get('mat_thr_density')).Value,
        E=App.Units.parseQuantity(sheet.get('mat_thr_E')).Value,
        k=App.Units.parseQuantity(sheet.get('mat_thr_k')).Value,
        cp=App.Units.parseQuantity(sheet.get('mat_thr_cp')).Value,
        name='Inconel'
    )
    set_color(thr_obj, (0.45, 0.45, 0.50), trans=0.0)

    set_material(
        shield_obj,
        density=App.Units.parseQuantity(sheet.get('mat_shield_density')).Value,
        E=App.Units.parseQuantity(sheet.get('mat_shield_E')).Value,
        k=App.Units.parseQuantity(sheet.get('mat_shield_k')).Value,
        cp=App.Units.parseQuantity(sheet.get('mat_shield_cp')).Value,
        name='AblativeShield'
    )
    set_color(shield_obj, (0.85, 0.30, 0.10), trans=0.1)

    # ------------- Masas aproximadas -------------
    def add_mass(obj):
        try:
            rho_str = obj.Material.get('Density', '0')
            rho = float(str(rho_str).split()[0])
            vol = obj.Shape.Volume  # m^3
            m = rho * vol
            if not hasattr(obj, 'Mass'):
                obj.addProperty('App::PropertyQuantity', 'Mass', 'Physics', 'Masa aproximada por densidad*volumen')
            obj.Mass = f'{m} kg'
        except Exception:
            pass

    for o in [bus_solid, payload_obj, thr_obj, shield_obj] + brk_objs:
        add_mass(o)

    if GUI_AVAILABLE:
        try:
            part.ViewObject.DisplayMode = 'ChildFeature'
        except Exception:
            pass

    return part

# ------------------------------ Ejecución ----------------------------------

doc = ensure_doc(DOC_NAME)
sheet = ensure_params_sheet(doc)
probe = build_probe(doc, sheet)

doc.recompute()

if GUI_AVAILABLE:
    try:
        Gui.activeDocument().activeView().viewIsometric()
        Gui.SendMsgToActiveView("ViewFit")
    except Exception:
        pass

# Fin del macro
