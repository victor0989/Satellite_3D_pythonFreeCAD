import FreeCAD as App
import FreeCADGui as Gui
import Part, math, os, sys

# ===================== Utilidades (helpers) =====================
def add_part(doc, shape, name, color=(0.8,0.8,0.8), transparency=0.0):
    if shape is None:
        return None
    try:
        obj = doc.addObject("Part::Feature", name)
        # shape puede ser un Part.Shape o un objeto con .Shape
        obj.Shape = shape.Shape if hasattr(shape, "Shape") else shape
        if hasattr(obj, "ViewObject"):
            obj.ViewObject.ShapeColor = color
            obj.ViewObject.Transparency = int(transparency * 100)
        return obj
    except Exception as e:
        App.Console.PrintError(f"add_part error for {name}: {e}\n")
        return None

def place_shape(shape, pos=None, rot_axis=None, rot_deg=0.0):
    shp = shape.copy() if hasattr(shape, "copy") else shape
    # aplicar rotación (si procede)
    if rot_axis is not None and abs(rot_deg) > 1e-9:
        try:
            rot = App.Rotation(rot_axis, rot_deg)
            shp.Placement = App.Placement(App.Vector(0,0,0), rot)
        except Exception as e:
            App.Console.PrintError(f"Rotation error: {e}\n")
    # aplicar traslación (si procede)
    if pos is not None:
        try:
            pl = shp.Placement if hasattr(shp, "Placement") else App.Placement()
            shp.Placement = App.Placement(App.Vector(pos.x, pos.y, pos.z), pl.Rotation)
        except Exception as e:
            App.Console.PrintError(f"Translation error: {e}\n")
    return shp

def fuse_safely(shapes):
    if not shapes:
        return None
    try:
        base = shapes[0]
        for s in shapes[1:]:
            try:
                base = base.fuse(s)
            except Exception:
                try:
                    base = Part.makeCompound([base, s])
                except Exception:
                    pass
        return base
    except Exception as e:
        App.Console.PrintError(f"fuse_safely error: {e}\n")
        try:
            return Part.makeCompound(shapes)
        except Exception as e2:
            App.Console.PrintError(f"Compound fallback failed: {e2}\n")
            return None

def make_ring(r_outer, r_inner, length, axis=App.Vector(1,0,0), base=App.Vector(0,0,0)):
    outer = Part.makeCylinder(r_outer, length, base, axis)
    inner = Part.makeCylinder(r_inner, length + 1e-6, base, axis)
    try:
        return outer.cut(inner)
    except Exception:
        return Part.makeCompound([outer, inner])

def make_trapezoid_plate(length, root_w, tip_w, thickness):
    p1 = App.Vector(0, -root_w/2.0, -thickness/2.0)
    p2 = App.Vector(0,  root_w/2.0, -thickness/2.0)
    p3 = App.Vector(0,  tip_w/2.0,  thickness/2.0)
    p4 = App.Vector(0, -tip_w/2.0,  thickness/2.0)
    wire = Part.makePolygon([p1, p2, p3, p4, p1])
    face = Part.Face(wire)
    plate = face.extrude(App.Vector(length, 0, 0))
    return plate

def make_revolved_solid_from_diameter(diameter, depth, steps=32):
    r = diameter / 2.0
    # perfil simple: arco + línea para cerrar (aprox)
    pts = []
    n = max(8, steps)
    for i in range(n+1):
        theta = math.pi * i / n
        x = -depth/2.0 + (depth) * (i / n)
        z = r * math.cos(theta)
        pts.append(App.Vector(x, z, 0))
    wire = Part.makePolygon(pts)
    face = Part.Face(wire)
    solid = face.revolve(App.Vector(0,0,0), App.Vector(0,1,0), 360)
    return solid

def make_dish_layer_solid(diameter, depth, thickness, steps=32):
    outer = make_revolved_solid_from_diameter(diameter, depth, steps)
    inner = make_revolved_solid_from_diameter(diameter - 2*thickness, depth, steps)
    try:
        return outer.cut(inner)
    except Exception:
        return outer

# ===================== Parámetros por defecto (mm; escalado para impresión) ====
p_bus_w = 50.0
p_bus_l = 120.0
p_bus_h = 30.0
bus_skin_t = 1.2

radiator_w = 20.0
radiator_h = 2.0
radiator_t = 1.5
radiator_back_offset = 6.0
radiator_fin_len = 8.0
radiator_fin_w = 1.0
radiator_fin_pitch = 3.0

paddle_len = 70.0
paddle_root_w = 30.0
paddle_tip_w = 18.0
paddle_t = 1.6
paddle_tilt_deg = 10.0
paddle_y_offset = 6.0

shield_back_standoff = 6.0
shield_d = 60.0
x0 = 0.0

tank_length = 60.0
tank_radius = 8.0

rwheel_r = 6.0
rwheel_t = 3.0

rcs_cone_r1 = 3.0
rcs_cone_r2 = 1.0
rcs_cone_h = 4.0

ion_body_r = 8.0
ion_body_L = 18.0
ion_grid_r_o = 6.0
ion_grid_r_i = 4.0
ion_grid_t = 1.0
ion_nozzle_r1 = 6.0
ion_nozzle_r2 = 1.5
ion_nozzle_L = 12.0

faraday_r = 8.0
faraday_len = 18.0
whip_r = 0.8
whip_len = 24.0

back_dish_d = 60.0
back_dish_depth = 10.0
boom_len_back = 60.0
boom_r = 1.8
t_bumper_ring = 0.8
steps_profile = 32

whipple_rad_clear = 4.0
whipple_t_bumper = 0.8
whipple_t_rear = 0.6
whipple_gap = 6.0
whipple_len_extra = 10.0

export_path = os.path.join(App.getUserAppDataDir(), "starlink_v2_mini_export.step")
export_as_single_compound = False

# ===================== Construcción: viguetas radiales =====================
def build_radial_struts(doc):
    objs = []
    for a in range(0, 360, 60):
        cyl = Part.makeCylinder(2.6, shield_back_standoff + 6.0)
        cyl = place_shape(cyl, rot_axis=App.Vector(0,1,0), rot_deg=90)
        y = (shield_d/2.0 - 18.0) * math.cos(math.radians(a))
        z = (shield_d/2.0 - 18.0) * math.sin(math.radians(a))
        cyl.translate(App.Vector(x0 - shield_back_standoff, y, z))
        objs.append(add_part(doc, cyl, f"TPS_Strut_{a}", color=(0.75,0.75,0.75)))
    return [o for o in objs if o]

# ===================== Panel solar con bisagras (paddles) =====================
def build_paddle(doc, side=+1):
    objs = []
    plate = make_trapezoid_plate(paddle_len, paddle_root_w, paddle_tip_w, paddle_t)
    hinge = Part.makeCylinder(2.4, 6.0, App.Vector(0,0,0), App.Vector(1,0,0))
    hinge = place_shape(hinge, rot_axis=App.Vector(0,1,0), rot_deg=90)
    arm_len = 15.0
    arm_r = 1.5
    arm = Part.makeCylinder(arm_r, arm_len, App.Vector(0,0,0), App.Vector(1,0,0))
    arm = place_shape(arm, pos=App.Vector(-arm_len/2.0,0,0), rot_axis=App.Vector(0,0,1), rot_deg=side*10)
    tilt = paddle_tilt_deg * (1 if side>0 else -1)
    plate_rot = place_shape(plate, rot_axis=App.Vector(0,0,1), rot_deg=tilt)
    hinge_rot = place_shape(hinge, rot_axis=App.Vector(0,0,1), rot_deg=tilt)
    arm_rot = place_shape(arm, rot_axis=App.Vector(0,0,1), rot_deg=tilt)
    x = p_bus_w/2.0 - 6.0
    y = side*(paddle_y_offset + paddle_t/2.0 + 2.0)
    z = 0.0
    for sh in (plate_rot, hinge_rot, arm_rot):
        sh.translate(App.Vector(x,y,z))
    bracket = Part.makeBox(6.0,8.0,12.0)
    bracket.translate(App.Vector(p_bus_w/2.0 - 6.0, y - 4.0, -6.0))
    objs += [
        add_part(doc, plate_rot, f"PaddlePlate_{'R' if side>0 else 'L'}", color=(0.16,0.36,0.76)),
        add_part(doc, hinge_rot, f"PaddleHinge_{'R' if side>0 else 'L'}", color=(0.6,0.6,0.6)),
        add_part(doc, arm_rot,   f"PaddleArm_{'R' if side>0 else 'L'}",   color=(0.5,0.5,0.5)),
        add_part(doc, bracket,   f"PaddleBracket_{'R' if side>0 else 'L'}", color=(0.45,0.45,0.48)),
    ]
    return objs

# ===================== Radiadores traseros con aletas =====================
def build_radiator(doc, side=+1):
    objs = []
    plate = Part.makeBox(radiator_t, radiator_w, radiator_h)
    x = -p_bus_w/2.0 - radiator_back_offset
    y = side * (p_bus_d/2.0 - radiator_w/2.0 - 6.0) if 'p_bus_d' in globals() else side*(p_bus_w/2.0 - radiator_w/2.0 - 6.0)
    z = -radiator_h/2.0
    plate.translate(App.Vector(x,y,z))
    objs.append(add_part(doc, plate, f"RadiatorPlate_{'R' if side>0 else 'L'}", color=(0.82,0.82,0.85)))
    n_fins = max(1, int(radiator_w // radiator_fin_pitch))
    for i in range(n_fins):
        fy = y - radiator_w/2.0 + (i+0.5)*radiator_fin_pitch
        fin = Part.makeBox(radiator_fin_len, radiator_fin_w, radiator_h)
        fin.translate(App.Vector(x - radiator_fin_len, fy - radiator_fin_w/2.0, -radiator_h/2.0))
        objs.append(add_part(doc, fin, f"RadiatorFin_{'R' if side>0 else 'L'}_{i}", color=(0.75,0.75,0.78)))
    return objs

# ===================== Tanque cápsula (propelente) =====================
def build_tank(doc):
    length = min(tank_length, p_bus_w - 2 * bus_skin_t - 10.0)
    cyl = Part.makeCylinder(tank_radius, length, App.Vector(-length/2.0, 0, -p_bus_h/4.0), App.Vector(1,0,0))
    hemi1 = Part.makeSphere(tank_radius, App.Vector(-length/2.0, 0, -p_bus_h/4.0))
    hemi2 = Part.makeSphere(tank_radius, App.Vector(+length/2.0, 0, -p_bus_h/4.0))
    big = 1000.0
    cut1 = Part.makeBox(big,big,big, App.Vector(-length/2.0 - big/2.0, -big/2.0, -p_bus_h/4.0 - big/2.0))
    cut2 = Part.makeBox(big,big,big, App.Vector(+length/2.0, -big/2.0, -p_bus_h/4.0 - big/2.0))
    hemi1 = hemi1.common(cut1)
    hemi2 = hemi2.common(cut2)
    tank = fuse_safely([cyl, hemi1, hemi2])
    return [add_part(doc, tank, "PropTank", color=(0.90,0.88,0.65), transparency=0.1)]

# ===================== Ruedas de reacción =====================
def build_reaction_wheels(doc):
    objs = []
    z0 = p_bus_h / 4.5
    spacing = 22.0
    for i, dy in enumerate((-spacing, 0.0, spacing)):
        rw = Part.makeCylinder(rwheel_r, rwheel_t, App.Vector(-rwheel_t/2.0, dy - rwheel_r, z0 - rwheel_r), App.Vector(1,0,0))
        objs.append(add_part(doc, rw, f"ReactionWheel_{i}", color=(0.35,0.35,0.38)))
    return objs

# ===================== RCS (8 toberas cónicas) =====================
def build_rcs(doc):
    objs = []
    for sideX, signX in (("Front", +1), ("Back", -1)):
        x = signX * (p_bus_w / 2.0)
        for j, (sy, sz) in enumerate(((+1,+1),(+1,-1),(-1,+1),(-1,-1))):
            y = sy * (p_bus_w / 2.0 - 8.0)
            z = sz * (p_bus_h / 2.0 - 8.0)
            base = App.Vector(x, y, z)
            axis = App.Vector(signX, 0, 0)
            cone = Part.makeCone(rcs_cone_r1, rcs_cone_r2, rcs_cone_h, base, axis)
            cone.translate(App.Vector(signX * 2.0, 0, 0))
            objs.append(add_part(doc, cone, f"RCS_{sideX}_{j}", color=(0.70,0.70,0.72)))
    return objs

# ===================== Propulsor iónico trasero =====================
def build_ion_thruster(doc):
    objs = []
    x_base = -p_bus_w/2.0 - 28.0
    body = Part.makeCylinder(ion_body_r, ion_body_L, App.Vector(x_base - ion_body_L, 0, 0), App.Vector(1,0,0))
    objs.append(add_part(doc, body, "Ion_Body", color=(0.45,0.45,0.50)))
    for k, dx in enumerate((2.0, 6.0, 10.0)):
        ring = make_ring(ion_grid_r_o, ion_grid_r_i, ion_grid_t, axis=App.Vector(1,0,0), base=App.Vector(x_base - dx, 0, 0))
        objs.append(add_part(doc, ring, f"Ion_Grid_{k}", color=(0.80,0.80,0.85), transparency=0.2))
    noz = Part.makeCone(ion_nozzle_r1, ion_nozzle_r2, ion_nozzle_L, App.Vector(x_base - ion_body_L - ion_nozzle_L, 0, 0), App.Vector(1,0,0))
    objs.append(add_part(doc, noz, "Ion_Nozzle", color=(0.55,0.55,0.58)))
    flange = make_ring(ion_body_r + 4.0, ion_body_r - 2.0, 3.0, axis=App.Vector(1,0,0), base=App.Vector(x_base + 2.0, 0, 0))
    objs.append(add_part(doc, flange, "Ion_Flange", color=(0.65,0.65,0.68)))
    for a in (-20, 0, +20):
        strut = Part.makeCylinder(1.6, 18.0, App.Vector(-p_bus_w/2.0, 0, 0), App.Vector(1,0,0))
        strut = place_shape(strut, pos=App.Vector(-p_bus_w/2.0 - 9.0, 0, 0), rot_axis=App.Vector(0,0,1), rot_deg=a)
        objs.append(add_part(doc, strut, f"Ion_Strut_{a}", color=(0.7,0.7,0.72)))
    return objs

# ===================== Antenas: jaula + látigo =====================
def build_antennas(doc):
    objs = []
    cage = Part.makeCylinder(faraday_r, faraday_len, App.Vector(0, 0, p_bus_h / 2.0), App.Vector(0,0,1))
    inner = Part.makeCylinder(faraday_r - 1.2, faraday_len, App.Vector(0, 0, p_bus_h / 2.0), App.Vector(0,0,1))
    cage = cage.cut(inner)
    objs.append(add_part(doc, cage, "FaradayCage", color=(0.86,0.78,0.40)))
    whip = Part.makeCylinder(whip_r, whip_len, App.Vector(-p_bus_w / 4.0, 0, p_bus_h / 2.0), App.Vector(0,0,1))
    objs.append(add_part(doc, whip, "WhipAntenna", color=(0.2,0.2,0.2)))
    return objs

# ===================== Plato trasero y botalones =====================
def build_back_dish_and_booms(doc):
    objs = []
    dish = make_revolved_solid_from_diameter(back_dish_d, back_dish_depth, steps_profile)
    dish_thin = make_dish_layer_solid(back_dish_d, back_dish_depth, t_bumper_ring, steps_profile)
    x = -p_bus_l/2.0 - boom_len_back - back_dish_depth/2.0
    dish = place_shape(dish, pos=App.Vector(x, 0, 0), rot_axis=App.Vector(0,1,0), rot_deg=90)
    dish_thin = place_shape(dish_thin, pos=App.Vector(x, 0, 0), rot_axis=App.Vector(0,1,0), rot_deg=90)
    objs.append(add_part(doc, dish, "BackDishSolid", color=(0.88,0.88,0.90), transparency=0.2))
    objs.append(add_part(doc, dish_thin, "BackDishShell", color=(0.95,0.95,0.95), transparency=0.6))
    boom = Part.makeCylinder(boom_r, boom_len_back, App.Vector(-p_bus_l/2.0 - boom_len_back, 0, 0), App.Vector(1,0,0))
    objs.append(add_part(doc, boom, "MainBoom", color=(0.7,0.7,0.72)))
    for idx, (yy, zz) in enumerate(((+1,+1),(+1,-1),(-1,+1),(-1,-1))):
        y = yy*(p_bus_w/2.0 - 10.0)
        z = zz*(p_bus_h/2.0 - 10.0)
        vec = App.Vector(-p_bus_l/2.0, y, z)
        length = boom_len_back
        brace = Part.makeCylinder(1.6, length, vec - App.Vector(length,0,0), App.Vector(1,0,0))
        objs.append(add_part(doc, brace, f"BoomBrace_{idx}", color=(0.7,0.7,0.72)))
    return objs

# ===================== Whipple skirt =====================
def build_whipple_skirt(doc):
    objs = []
    r_bus = max(p_bus_w, p_bus_h)/2.0
    r_outer = r_bus + whipple_rad_clear + whipple_t_bumper + whipple_t_rear + whipple_gap
    L = p_bus_l + whipple_len_extra
    bumper = make_ring(r_outer, r_outer - whipple_t_bumper, L, axis=App.Vector(1,0,0), base=App.Vector(-L/2.0, 0, 0))
    rear = make_ring(r_outer - whipple_t_bumper - whipple_gap, r_outer - whipple_t_bumper - whipple_gap - whipple_t_rear, L, axis=App.Vector(1,0,0), base=App.Vector(-L/2.0, 0, 0))
    spokes = []
    for i in range(12):
        ang = 2*math.pi*i/12.0
        y = (r_outer - whipple_t_bumper/2.0) * math.cos(ang)
        z = (r_outer - whipple_t_bumper/2.0) * math.sin(ang)
        sp = Part.makeCylinder(0.9, L, App.Vector(-L/2.0, y, z), App.Vector(1,0,0))
        spokes.append(sp)
    cut_w = radiator_w + 22.0
    cut_h = p_bus_h + 40.0
    cut_len = L + 4.0
    for side in (+1,-1):
        cut_box = Part.makeBox(cut_len, cut_w, cut_h, App.Vector(-cut_len/2.0, side*(-cut_w/2.0), -cut_h/2.0))
        bumper = bumper.cut(cut_box)
        rear   = rear.cut(cut_box)
    full = fuse_safely([bumper, rear] + spokes)
    objs.append(add_part(doc, full, "WhippleSkirt", color=(0.75,0.75,0.80), transparency=0.2))
    return objs

# ===================== Star trackers =====================
def build_star_trackers(doc):
    objs = []
    box = Part.makeBox(12.0, 12.0, 12.0)
    lens = Part.makeCylinder(4.0, 10.0, App.Vector(12.0, 6.0, 6.0), App.Vector(1,0,0))
    head = fuse_safely([box, lens])
    z_top = p_bus_h/2.0 + 8.0
    for i, y in enumerate((-p_bus_w/4.0, +p_bus_w/4.0)):
        head_i = place_shape(head, pos=App.Vector(0, y, z_top), rot_axis=App.Vector(0,1,0), rot_deg=15*(-1 if i==0 else 1))
        objs.append(add_part(doc, head_i, f"StarTracker_{i}", color=(0.80,0.82,0.88)))
    return objs

# ===================== Magnetometer boom =====================
def build_magnetometer_boom(doc):
    objs = []
    base = Part.makeCylinder(1.2, 20.0, App.Vector(0,0,p_bus_h/2.0), App.Vector(0,0,1))
    rod  = Part.makeCylinder(0.9, 85.0, App.Vector(0,0,p_bus_h/2.0+20.0), App.Vector(0,0,1))
    tip  = Part.makeSphere(2.5, App.Vector(0,0,p_bus_h/2.0+20.0+85.0))
    objs += [
        add_part(doc, base, "MagBoomBase", color=(0.7,0.7,0.72)),
        add_part(doc, rod,  "MagBoomRod",  color=(0.7,0.7,0.72)),
        add_part(doc, tip,  "MagBoomSensor", color=(0.95,0.95,0.95)),
    ]
    return objs

# ===================== Payload bay =====================
def build_payload_bay(doc):
    objs = []
    box = Part.makeBox(40.0, 40.0, 30.0)
    box.translate(App.Vector(-p_bus_l/2.0 - 20.0, -20.0, -15.0))
    objs.append(add_part(doc, box, "PayloadBay", color=(0.55,0.58,0.65)))
    return objs

# ===================== Solar panels (simple printing-friendly) =====================
def build_solar_panels(doc):
    objs = []
    panel_thk = 1.2
    hinge_offset = p_bus_l / 2.0 - 2.0
    panel_r = Part.makeBox(paddle_len, paddle_root_w, panel_thk, App.Vector(hinge_offset, -paddle_root_w/2.0, 0))
    objs.append(add_part(doc, panel_r, "PanelRight", color=(0.1,0.1,0.4)))
    panel_l = Part.makeBox(paddle_len, paddle_root_w, panel_thk, App.Vector(-hinge_offset - paddle_len, -paddle_root_w/2.0, 0))
    objs.append(add_part(doc, panel_l, "PanelLeft", color=(0.1,0.1,0.4)))
    return objs

# ===================== Thrusters (printing-friendly) =====================
def build_thrusters(doc):
    objs = []
    for i in range(4):
        x = (-p_bus_l / 3.0) + i * (p_bus_l / 4.5)
        y = p_bus_w / 2.0
        thr = Part.makeCylinder(0.9, 3.5, App.Vector(x, y, -p_bus_h/3.0), App.Vector(0,0,-1))
        objs.append(add_part(doc, thr, f"Thruster_{i+1}", color=(0.3,0.3,0.3)))
    return objs

# ===================== Bus (simple) =====================
def build_bus(doc):
    objs = []
    shell = Part.makeBox(p_bus_l, p_bus_w, p_bus_h, App.Vector(-p_bus_l/2.0, -p_bus_w/2.0, -p_bus_h/2.0))
    objs.append(add_part(doc, shell, "BusShell", color=(0.7,0.7,0.75)))
    return objs

# ===================== Ensamblaje completo =====================
def build_satellite(doc):
    all_objs = []
    all_objs += build_bus(doc)
    all_objs += build_radial_struts(doc)
    all_objs += build_paddle(doc, side=+1)
    all_objs += build_paddle(doc, side=-1)
    all_objs += build_radiator(doc, side=+1)
    all_objs += build_radiator(doc, side=-1)
    all_objs += build_tank(doc)
    all_objs += build_reaction_wheels(doc)
    all_objs += build_rcs(doc)
    all_objs += build_ion_thruster(doc)
    all_objs += build_antennas(doc)
    all_objs += build_back_dish_and_booms(doc)
    all_objs += build_whipple_skirt(doc)
    all_objs += build_star_trackers(doc)
    all_objs += build_magnetometer_boom(doc)
    all_objs += build_payload_bay(doc)
    all_objs += build_solar_panels(doc)
    all_objs += build_thrusters(doc)
    return [o for o in all_objs if o]

# ===================== Principal: documento y exportación =====================
def main():
    doc_name = "StarlinkV2_Mini_Print"
    doc = App.ActiveDocument
    if not doc or doc.Name != doc_name:
        doc = App.newDocument(doc_name)
    App.ActiveDocument = doc
    objs = build_satellite(doc)
    doc.recompute()
    try:
        if export_as_single_compound:
            shapes = [o.Shape for o in objs if hasattr(o, "Shape")]
            comp = Part.Compound(shapes)
            tmp = doc.addObject("Part::Feature", "CompoundAll")
            tmp.Shape = comp
            Part.export([tmp], export_path)
        else:
            Part.export(objs, export_path)
        App.Console.PrintMessage("Exportado STEP en: {}\n".format(export_path))
    except Exception as e:
        App.Console.PrintError("Error exportando STEP: {}\n".format(e))
    try:
        stl_path = os.path.splitext(export_path)[0] + ".stl"
        stl_objs = [o for o in objs if hasattr(o, "Shape")]
        Part.export(stl_objs, stl_path)
        App.Console.PrintMessage("Exportado STL en: {}\n".format(stl_path))
    except Exception as e:
        App.Console.PrintError("Error exportando STL: {}\n".format(e))
    try:
        Gui.SendMsgToActiveView("ViewFit")
        Gui.activeDocument().activeView().viewAxometric()
    except Exception:
        pass

if __name__ == "__main__":
    main()
