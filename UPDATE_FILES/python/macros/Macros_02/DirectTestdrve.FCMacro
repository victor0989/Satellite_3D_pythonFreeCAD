import FreeCAD as App
import FreeCADGui as Gui
import Part
import math
import os

# =====================
# Configuración general
# =====================
DOC_NAME = "Direct_Fusion_Drive_improved"
EXPORT_STEP = False  # True -> export STEP al terminar
STEP_PATH = os.path.join(App.getUserAppDataDir(), "DFD_improved.step")

# Limpia o crea documento nuevo evitando duplicados en ejecuciones repetidas
if App.ActiveDocument and App.ActiveDocument.Label == DOC_NAME:
    doc = App.ActiveDocument
    # eliminamos los objetos previos si existen para ejecutar macro "limpio"
    for obj in list(doc.Objects):
        try:
            doc.removeObject(obj.Name)
        except Exception:
            pass
else:
    # si existe otro documento con el mismo nombre, lo eliminamos para evitar confusión
    if DOC_NAME in [d.Label for d in App.listDocuments().values()]:
        for name, d in list(App.listDocuments().items()):
            if d.Label == DOC_NAME:
                App.closeDocument(name)
    doc = App.newDocument(DOC_NAME)

# ============
# Parámetros
# ============
P = {
    # Fuselaje
    "nose_len": 800.0,
    "nose_base_d": 600.0,
    "mid_len": 1400.0,
    "mid_d": 900.0,
    "rear_len": 800.0,
    "rear_d": 1200.0,
    "hull_t": 10.0,
    # Cabina
    "cockpit_w": 900.0,
    "cockpit_h": 400.0,
    "cockpit_l": 600.0,
    "cockpit_x0": 600.0,
    # Ventanas laterales
    "win_w": 600.0,
    "win_h": 250.0,
    "win_th": 20.0,
    "win_z": 0.0,
    # Reactor
    "reactor_d": 800.0,
    "reactor_l": 900.0,
    "reactor_cx": 2600.0,
    "ring_h": 30.0,
    "ring_ro": 420.0,
    "ring_ri": 380.0,
    "ring_n": 6,
    "ring_pitch": 150.0,
    # Coils
    "coil_rect_w": 80.0,
    "coil_rect_h": 80.0,
    "coil_R": 440.0,
    "coil_n": 4,
    "coil_span": 800.0,
    # Blindajes
    "moderator_t": 100.0,
    "moderator_gap": 20.0,
    "moderator_over": 200.0,
    "tungsten_post_t": 10.0,
    # Boquilla
    "nozzle_throat_d": 300.0,
    "nozzle_exit_d": 900.0,
    "nozzle_l": 700.0,
    "nozzle_cx": 2850.0,
    "nozzle_fillet_r": 40.0,
    # Truss
    "truss_n": 3,
    "truss_tube_w": 80.0,
    "truss_R_attach": 550.0,
    # Tanques
    "tank_d": 300.0,
    "tank_l": 700.0,
    "tank_cx": 1600.0,
    "tank_cy": 300.0,
    "tank_cz": -150.0,
    # Tren
    "leg_L_fold": 400.0,
    "leg_L_ext": 600.0,
    "leg_foot_d": 180.0,
    "leg_side_x1": 1050.0,
    "leg_side_x2": 1950.0,
    "leg_side_y": 600.0,
    "leg_front_x": 400.0,
    "leg_front_y": 0.0,
    "leg_front_z": - (900.0/2.0) + 50.0,
    # Alas
    "wing_root_w": 600.0,
    "wing_tip_w": 150.0,
    "wing_chord": 450.0,
    "fin_h": 400.0,
    "fin_base": 200.0,
    # Radiadores
    "rad_panel_w": 800.0,
    "rad_panel_h": 600.0,
    "rad_panel_n": 5,
}

# -------------
# Validaciones
# -------------
def validate_params(P):
    assert P["nose_len"] > 0 and P["nose_base_d"] > 0
    assert P["mid_len"] > 0 and P["mid_d"] > 0
    assert P["rear_len"] > 0

validate_params(P)

# =================
# Utilidades generales
# =================
X_AXIS = App.Vector(1,0,0)
Y_AXIS = App.Vector(0,1,0)
Z_AXIS = App.Vector(0,0,1)

def rot_to_x():
    # Rotación que orienta la dirección Z -> X
    return App.Rotation(Y_AXIS, 90)

# Añade objeto al documento con nombre, evita añadir duplicados
def add_obj(shape, label):
    # shape puede ser Part.Shape o Part.Compound
    obj = doc.addObject("Part::Feature", label)
    obj.Shape = shape
    return obj

# Creación de primitivas alineadas con eje X (más robustas)

def make_cyl_x(d, L, cx=0.0, cy=0.0, cz=0.0, label="CylX"):
    r = float(d)/2.0
    cyl = Part.makeCylinder(r, L)
    # Alineamos el eje del cilindro a X y centramos en cx
    cyl.Placement = App.Placement(App.Vector(cx - L/2.0, cy, cz), rot_to_x())
    return add_obj(cyl, label)


def make_cone_x(d1, d2, L, cx=0.0, cy=0.0, cz=0.0, label="ConeX"):
    r1 = float(d1)/2.0
    r2 = float(d2)/2.0
    cone = Part.makeCone(r1, r2, L)
    cone.Placement = App.Placement(App.Vector(cx - L/2.0, cy, cz), rot_to_x())
    return add_obj(cone, label)


def make_torus_x(R, r, cx=0.0, cy=0.0, cz=0.0, label="TorusX"):
    tor = Part.makeTorus(R, r)
    tor.Placement = App.Placement(App.Vector(cx, cy, cz), rot_to_x())
    return add_obj(tor, label)


def make_box(w, d, h, cx=0.0, cy=0.0, cz=0.0, label="Box"):
    b = Part.makeBox(w, d, h)
    b.Placement = App.Placement(App.Vector(cx - w/2.0, cy - d/2.0, cz - h/2.0), App.Rotation())
    return add_obj(b, label)

# Offset shell con fallback

def make_hollow_from_offset(shape, t, label="Shell"):
    try:
        inner = shape.makeOffsetShape(-t, 0.01, join=2, fill=True)
        shell_shape = shape.cut(inner)
        return add_obj(shell_shape, label)
    except Exception as e:
        App.Console.PrintWarning("Offset failed: {}\n".format(e))
        # intentar con escalado simple como fallback (no es perfecto)
        return add_obj(shape, label + "_solid_fallback")

# Fillet heurístico (devuelve Shape)

def fillet_between(shapeA, shapeB, r):
    try:
        fused = shapeA.fuse(shapeB)
        # filtro de aristas por curvatura / longitud
        edges = [e for e in fused.Edges if e.Length > (r*0.2)]
        if not edges:
            return fused
        result = fused.makeFillet(float(r), edges)
        return result
    except Exception as e:
        App.Console.PrintWarning("Fillet failed: {}\n".format(e))
        return shapeA.fuse(shapeB)

# Tagging de materiales: crea propiedades si no existen

def tag_material(obj, material_name, density):
    try:
        if not hasattr(obj, 'Material'):
            obj.addProperty('App::PropertyString', 'Material', 'Physics', 'Material asignado')
        if not hasattr(obj, 'Density'):
            obj.addProperty('App::PropertyFloat', 'Density', 'Physics', 'Densidad kg/m^3')
    except Exception:
        pass
    obj.Material = str(material_name)
    try:
        obj.Density = float(density)
    except Exception:
        obj.Density = 0.0

# =========================
# 1) Fuselaje exterior hueco
# =========================
nose = make_cone_x(P["nose_base_d"], 0.0, P["nose_len"], cx=P["nose_len"]/2.0, label="Nose")
mid  = make_cyl_x(P["mid_d"], P["mid_len"], cx=P["nose_len"] + P["mid_len"]/2.0, label="Mid")
rear = make_cyl_x(P["rear_d"], P["rear_len"], cx=P["nose_len"] + P["mid_len"] + P["rear_len"]/2.0, label="Rear")

# Fusionar y crear shell interior (espesor hacia dentro)
fuse_fuselage_shape = nose.Shape.fuse(mid.Shape).fuse(rear.Shape)
hull = make_hollow_from_offset(fuse_fuselage_shape, P["hull_t"], label="Hull_Shell")

# Ventanas laterales (restas) - posicionamiento centrado en X de la cabina
win_cx = P["cockpit_x0"] + P["cockpit_l"]/2.0
win1 = make_box(P["win_w"], P["win_th"], P["win_h"], cx=win_cx,
                cy=(P["mid_d"]/2.0) - P["win_th"]/2.0, cz=P["win_z"], label="Win_Right")
win2 = make_box(P["win_w"], P["win_th"], P["win_h"], cx=win_cx,
                cy=-(P["mid_d"]/2.0) + P["win_th"]/2.0, cz=P["win_z"], label="Win_Left")

# Aplicamos cortes de ventanas al hull (con fallback si falla)
try:
    hull_cut_shape = hull.Shape.cut(win1.Shape).cut(win2.Shape)
    hull_cut = add_obj(hull_cut_shape, "Hull_Shell_Cut")
except Exception as e:
    App.Console.PrintWarning("Hull cut failed: {}\n".format(e))
    hull_cut = hull

# =========================
# 2) Cabina interior (box redondeada)
# =========================
cockpit_box = Part.makeBox(P["cockpit_l"], P["cockpit_w"], P["cockpit_h"])
cockpit_box.Placement = App.Placement(App.Vector(P["cockpit_x0"], -P["cockpit_w"]/2.0, -P["cockpit_h"]/2.0), App.Rotation())
try:
    # fillet en aristas del box (si falla se queda el box)
    cockpit_f = cockpit_box.makeFillet(20.0, cockpit_box.Edges)
except Exception:
    cockpit_f = cockpit_box
cockpit = add_obj(cockpit_f, "Cockpit")

# =========================
# 3) Reactor DFD
# =========================
reactor = make_cyl_x(P["reactor_d"], P["reactor_l"], cx=P["reactor_cx"], label="ReactorCore")

# Anillos estructurales (torus) distribuidos a lo largo del reactor
rings = []
if P["ring_n"] > 0:
    x0 = P["reactor_cx"] - P["reactor_l"]/2.0 + P["ring_h"]/2.0
    for i in range(P["ring_n"]):
        x = x0 + i * P["ring_pitch"]
        t = Part.makeTorus((P["ring_ro"]+P["ring_ri"]) / 2.0, (P["ring_ro"]-P["ring_ri"]) / 2.0)
        t.Placement = App.Placement(App.Vector(x, 0, 0), rot_to_x())
        rings.append(t)

rings_shape = rings[0] if rings else reactor.Shape
for r in rings[1:]:
    rings_shape = rings_shape.fuse(r)
rings_obj = add_obj(rings_shape, "Reactor_Rings")

# Bobinas (coil): simplificadas como torus rectangulares aproximados mediante extrusión
coils = []
if P["coil_n"] > 0:
    span = P["coil_span"]
    cx0 = P["reactor_cx"] - span/2.0
    for i in range(P["coil_n"]):
        cx = cx0 + i * (span / max(1, (P["coil_n"] - 1)))
        # creamos un toro pequeño y lo fusionamos para simular la bobina
        coil = Part.makeTorus(P["coil_R"], max(P["coil_rect_w"], P["coil_rect_h"]) / 2.0)
        coil.Placement = App.Placement(App.Vector(cx, 0, 0), rot_to_x())
        coils.append(coil)

if coils:
    coils_shape = coils[0]
    for c in coils[1:]:
        coils_shape = coils_shape.fuse(c)
    coils_obj = add_obj(coils_shape, "Reactor_Coils")
else:
    coils_obj = None

# Blindaje posterior tungsteno (anillo axial)
tw_len = P.get("tungsten_post_t", 10.0)
tw_ro = P["reactor_d"]/2.0
tw_ri = tw_ro - 10.0
if tw_ri <= 0:
    tw_ri = tw_ro * 0.9

tw_tube = Part.makeCylinder(tw_ro, tw_len)
tw_hole = Part.makeCylinder(tw_ri, tw_len + 0.1)
tw_ring = tw_tube.cut(tw_hole)
tw_ring.Placement = App.Placement(App.Vector(P["reactor_cx"] + P["reactor_l"]/2.0 - tw_len/2.0, 0, 0), rot_to_x())
tw_obj = add_obj(tw_ring, "Tungsten_Posterior")

# =========================
# 4) Boquilla magnética
# =========================
noz = Part.makeCone(P["nozzle_throat_d"]/2.0, P["nozzle_exit_d"]/2.0, P["nozzle_l"]) 
noz.Placement = App.Placement(App.Vector(P["nozzle_cx"] - P["nozzle_l"]/2.0, 0, 0), rot_to_x())
noz_obj = add_obj(noz, "Magnetic_Nozzle")

# Intento de blend/fillet en unión boquilla-cola
try:
    filleted_nozzle = fillet_between(rear.Shape, noz, P.get("nozzle_fillet_r", 20.0))
    nozzle_mount = add_obj(filleted_nozzle, "Nozzle_Mount_Fillet")
except Exception:
    nozzle_mount = noz_obj

# Truss de soporte (simplificado: 3 vigas)
truss_list = []
for k in range(P.get("truss_n", 3)):
    ang = k * (360.0 / P.get("truss_n", 3))
    x_attach = P["nose_len"] + P["mid_len"] + P["rear_len"] - 50.0
    y = P["truss_R_attach"] * math.cos(math.radians(ang))
    z = P["truss_R_attach"] * math.sin(math.radians(ang))
    L = 300.0
    beam = Part.makeBox(L, P["truss_tube_w"], P["truss_tube_w"])
    beam.Placement = App.Placement(App.Vector(x_attach - L/2.0, y - P["truss_tube_w"]/2.0, z - P["truss_tube_w"]/2.0), App.Rotation())
    truss_list.append(beam)

truss_shape = truss_list[0] if truss_list else None
for t in truss_list[1:]:
    truss_shape = truss_shape.fuse(t)
if truss_shape:
    truss_obj = add_obj(truss_shape, "Nozzle_Truss")
else:
    truss_obj = None

# =========================
# 5) Blindajes principal (moderador) + anillo tobera
# =========================
mod_inner_r = P["reactor_d"]/2.0 + P["moderator_gap"]
mod_outer_r = mod_inner_r + P["moderator_t"]
mod_len = P["reactor_l"] + P["moderator_over"]
mod_cx = P["reactor_cx"]

mod_outer = Part.makeCylinder(mod_outer_r, mod_len)
mod_inner = Part.makeCylinder(mod_inner_r, mod_len + 0.2)
mod_tube = mod_outer.cut(mod_inner)
mod_tube.Placement = App.Placement(App.Vector(mod_cx - mod_len/2.0, 0, 0), rot_to_x())
mod_obj = add_obj(mod_tube, "Shield_Moderator")

# Anillo posterior de tungsteno alrededor de tobera
tn_ro = P["nozzle_exit_d"]/2.0 + 40.0
tn_ri = tn_ro - 10.0
tn_len = 20.0
tn_tube = Part.makeCylinder(tn_ro, tn_len)
tn_hole = Part.makeCylinder(tn_ri, tn_len + 0.1)
tn_ring = tn_tube.cut(tn_hole)
tn_ring.Placement = App.Placement(App.Vector(P["nozzle_cx"] + P["nozzle_l"]/2.0 - tn_len/2.0, 0, 0), rot_to_x())
tn_obj = add_obj(tn_ring, "Tungsten_Nozzle_Rim")

# =========================
# 6) Tanques de combustible
# =========================
tank1 = make_cyl_x(P["tank_d"], P["tank_l"], cx=P["tank_cx"], cy=P["tank_cy"], cz=P["tank_cz"], label="Tank_Right")
tank2 = make_cyl_x(P["tank_d"], P["tank_l"], cx=P["tank_cx"], cy=-P["tank_cy"], cz=P["tank_cz"], label="Tank_Left")

# =========================
# 7) Tren de aterrizaje (simplificado)
# =========================
def make_leg(x, y, z, L, d, label):
    shaft = Part.makeCylinder(d/4.0, L)
    foot = Part.makeCylinder(d/2.0, 20.0)
    shaft.Placement = App.Placement(App.Vector(x - L/2.0, y, z), rot_to_x())
    foot.Placement  = App.Placement(App.Vector(x + L/2.0 - 10.0, y, z - d/4.0), App.Rotation())
    leg = shaft.fuse(foot)
    return add_obj(leg, label)

leg_r = make_leg(P["leg_side_x1"],  P["leg_side_y"],  P["leg_front_z"], P["leg_L_fold"], P["leg_foot_d"], "Leg_Right_Front")
leg_l = make_leg(P["leg_side_x1"], -P["leg_side_y"],  P["leg_front_z"], P["leg_L_fold"], P["leg_foot_d"], "Leg_Left_Front")
leg_r2= make_leg(P["leg_side_x2"],  P["leg_side_y"],  P["leg_front_z"], P["leg_L_fold"], P["leg_foot_d"], "Leg_Right_Rear")
leg_l2= make_leg(P["leg_side_x2"], -P["leg_side_y"],  P["leg_front_z"], P["leg_L_fold"], P["leg_foot_d"], "Leg_Left_Rear")
leg_f = make_leg(P["leg_front_x"],  P["leg_front_y"], P["leg_front_z"], P["leg_L_fold"], P["leg_foot_d"], "Leg_Nose")

# =========================
# 8) Aletas / alas cortas (simplificado)
# =========================
def make_trapezoid_wing(root_w, tip_w, chord, thickness=20.0, x0=1400.0, side=1, label="Wing"):
    # creamos un simple prismo trapezoidal y lo posicionamos
    x_le = x0
    x_te = x0 + chord
    z_mid = 0.0
    # vértices en plano XZ
    p1 = App.Vector(x_le, 0, z_mid + root_w/2.0)
    p2 = App.Vector(x_te, 0, z_mid + root_w/2.0)
    p3 = App.Vector(x_te, 0, z_mid + tip_w/2.0)
    p4 = App.Vector(x_le, 0, z_mid + tip_w/2.0)
    wire = Part.makePolygon([p1,p2,p3,p4,p1])
    face = Part.Face(wire)
    solid = face.extrude(App.Vector(0, side * (root_w - tip_w), 0))
    slab = Part.makeBox(chord, thickness, (root_w + tip_w)/2.0)
    slab.Placement = App.Placement(App.Vector(x0, side * thickness/2.0, z_mid - (root_w + tip_w)/4.0), App.Rotation())
    try:
        wing = solid.common(slab)
    except Exception:
        wing = slab
    return add_obj(wing, label)

wing_r = make_trapezoid_wing(P["wing_root_w"], P["wing_tip_w"], P["wing_chord"], x0=P["nose_len"] + 500.0, side=1, label="Wing_Right")
wing_l = make_trapezoid_wing(P["wing_root_w"], P["wing_tip_w"], P["wing_chord"], x0=P["nose_len"] + 500.0, side=-1, label="Wing_Left")

# Empeñaje vertical

def make_fin(h, base, thickness=20.0, x_base=None, label="Fin"):
    if x_base is None:
        x_base = P["nose_len"] + P["mid_len"] + P["rear_len"] - 300.0
    p1 = App.Vector(x_base, 0, 0)
    p2 = App.Vector(x_base + base, 0, 0)
    p3 = App.Vector(x_base, 0, h)
    wire = Part.makePolygon([p1,p2,p3,p1])
    face = Part.Face(wire)
    fin = face.extrude(App.Vector(0, thickness, 0))
    fin.Placement = App.Placement(App.Vector(0, -thickness/2.0, 0), App.Rotation())
    return add_obj(fin, label)

fin = make_fin(P["fin_h"], P["fin_base"], x_base=P["nose_len"] + P["mid_len"] + 200.0, label="Fin_Vertical")

# =========================
# 9) Radiadores laterales (opcionales)
# =========================
rads = []
for i in range(int(P.get("rad_panel_n", 0))):
    x = P["nose_len"] + 200.0 + i * (P["rad_panel_w"] / max(1, P["rad_panel_n"]))
    y = (P["mid_d"]/2.0) + 30.0
    z = 0.0
    panel = Part.makeBox(P["rad_panel_w"], 10.0, P["rad_panel_h"]) 
    panel.Placement = App.Placement(App.Vector(x - P["rad_panel_w"]/2.0, y - 5.0, z - P["rad_panel_h"]/2.0), App.Rotation())
    panel2 = Part.makeBox(P["rad_panel_w"], 10.0, P["rad_panel_h"]) 
    panel2.Placement = App.Placement(App.Vector(x - P["rad_panel_w"]/2.0, -y - 5.0, z - P["rad_panel_h"]/2.0), App.Rotation())
    rads.append(panel)
    rads.append(panel2)

rads_obj = None
if rads:
    radS = rads[0]
    for p in rads[1:]:
        radS = radS.fuse(p)
    rads_obj = add_obj(radS, "Radiators")

# =========================
# 10) Montaje lógico (compuestos / grupo)
# =========================
grp = doc.addObject("App::Part", "DFD_Ship")
objs_to_add = [hull_cut, cockpit, reactor, rings_obj, coils_obj, tw_obj, nozzle_mount, truss_obj,
               mod_obj, tn_obj, tank1, tank2, leg_r, leg_l, leg_r2, leg_l2, leg_f, wing_r, wing_l, fin]

for o in objs_to_add:
    if o is None:
        continue
    try:
        grp.addObject(o)
    except Exception:
        pass

if rads_obj:
    try:
        grp.addObject(rads_obj)
    except Exception:
        pass

# =========================
# 11) Propiedades de material (densidades)
# =========================
tag_material(hull_cut, "Ti-6Al-4V", 4500)
tag_material(reactor, "Estructural", 8000)
tag_material(rings_obj, "Estructural", 8000)
if coils_obj: tag_material(coils_obj, "Nb3Sn/NbTi", 8000)
tag_material(mod_obj, "Hydrogen-Composite", 1000)
tag_material(tw_obj, "Tungsten", 19250)
tag_material(tn_obj, "Tungsten", 19250)
tag_material(noz_obj, "Estructural", 8000)
if truss_obj: tag_material(truss_obj, "Inconel/Ti", 8500)
tag_material(tank1, "Al7075/Hydride", 2700)
tag_material(tank2, "Al7075/Hydride", 2700)
tag_material(cockpit, "CFRP", 1600)
if rads_obj: tag_material(rads_obj, "Graphene-Composite", 1700)

# =========================
# 12) Recompute y vistas
# =========================
doc.recompute()
try:
    Gui.ActiveDocument.ActiveView.viewAxonometric()
    Gui.SendMsgToActiveView("ViewFit")
except Exception:
    pass

# Export opcional a STEP
if EXPORT_STEP:
    try:
        shapes = [o.Shape for o in grp.OutList if hasattr(o, 'Shape')]
        compound = Part.makeCompound(shapes)
        Part.export([doc.addObject('Part::Feature','_tmp').__class__], STEP_PATH)
    except Exception as e:
        App.Console.PrintWarning("STEP export failed: {}\n".format(e))

print("Macro DFD (mejorado) completado: documento '{}'".format(doc.Label))
